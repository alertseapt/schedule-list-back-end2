const express = require('express');
const { authenticateToken, requireAdmin } = require('../middleware/auth');
const dpVerificationService = require('../services/dpVerificationService');

const router = express.Router();

// Todas as rotas requerem autentica√ß√£o de admin
router.use(authenticateToken);
router.use(requireAdmin);

/**
 * Inicia o servi√ßo de verifica√ß√£o de DP
 */
router.post('/start', async (req, res) => {
  try {
    dpVerificationService.start();
    
    res.json({
      success: true,
      message: 'Servi√ßo de verifica√ß√£o de DP iniciado com sucesso',
      status: dpVerificationService.getStatus()
    });
  } catch (error) {
    console.error('Erro ao iniciar servi√ßo de verifica√ß√£o de DP:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

/**
 * Para o servi√ßo de verifica√ß√£o de DP
 */
router.post('/stop', async (req, res) => {
  try {
    dpVerificationService.stop();
    
    res.json({
      success: true,
      message: 'Servi√ßo de verifica√ß√£o de DP parado com sucesso',
      status: dpVerificationService.getStatus()
    });
  } catch (error) {
    console.error('Erro ao parar servi√ßo de verifica√ß√£o de DP:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

/**
 * Obt√©m o status do servi√ßo de verifica√ß√£o de DP
 */
router.get('/status', async (req, res) => {
  try {
    const status = dpVerificationService.getStatus();
    
    res.json({
      success: true,
      status: status
    });
  } catch (error) {
    console.error('Erro ao obter status do servi√ßo:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

/**
 * For√ßa verifica√ß√£o manual de um agendamento espec√≠fico
 */
router.post('/verify/:scheduleId', async (req, res) => {
  try {
    const { scheduleId } = req.params;
    
    if (!scheduleId || isNaN(scheduleId)) {
      return res.status(400).json({
        success: false,
        message: 'ID do agendamento inv√°lido'
      });
    }

    const result = await dpVerificationService.forceVerification(parseInt(scheduleId));
    
    if (result.success) {
      res.json({
        success: true,
        message: result.message,
        dpNumber: result.dpNumber,
        scheduleId: parseInt(scheduleId)
      });
    } else {
      res.status(404).json({
        success: false,
        message: result.message,
        scheduleId: parseInt(scheduleId)
      });
    }
  } catch (error) {
    console.error('Erro na verifica√ß√£o manual:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

/**
 * Executa uma verifica√ß√£o completa manual (sem esperar o intervalo)
 */
router.post('/run-verification', async (req, res) => {
  try {
    // Executar verifica√ß√£o de forma ass√≠ncrona para n√£o bloquear a resposta
    dpVerificationService.runVerification().then(() => {
      console.log('‚úÖ Verifica√ß√£o manual completa executada');
    }).catch(error => {
      console.error('‚ùå Erro na verifica√ß√£o manual completa:', error);
    });
    
    res.json({
      success: true,
      message: 'Verifica√ß√£o manual iniciada. Verifique os logs para acompanhar o progresso.',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Erro ao executar verifica√ß√£o manual:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

/**
 * Busca DP com triangula√ß√£o rigorosa (CNPJ + NF + Data de inclus√£o)
 */
router.get('/search-dp-triangulation', async (req, res) => {
  try {
    const { nf_number, client_cnpj, schedule_id } = req.query;
    
    if (!nf_number || !client_cnpj || !schedule_id) {
      return res.status(400).json({
        success: false,
        message: 'Par√¢metros nf_number, client_cnpj e schedule_id s√£o obrigat√≥rios para triangula√ß√£o',
        required_params: ['nf_number', 'client_cnpj', 'schedule_id']
      });
    }

    // Usar servi√ßo de triangula√ß√£o rigorosa
    const DPVerificationServiceWithDate = require('../services/dpVerificationServiceWithDate');
    const dpService = new DPVerificationServiceWithDate();
    
    console.log(`üîç [API-TRIANGULATION] Buscando DP com triangula√ß√£o rigorosa`);
    console.log(`   NF: ${nf_number}, CNPJ: ${client_cnpj}, Schedule ID: ${schedule_id}`);
    
    const dpResult = await dpService.getDPFromWtrTableWithTriangulation(
      nf_number, 
      client_cnpj, 
      parseInt(schedule_id)
    );
    
    if (dpResult && dpResult.triangulation_complete) {
      console.log(`‚úÖ [API-TRIANGULATION] DP encontrado com triangula√ß√£o v√°lida: ${dpResult.dp_number}`);
      
      res.json({
        success: true,
        message: 'DP encontrado com triangula√ß√£o v√°lida (CNPJ + NF + Data)',
        no_dp: dpResult.dp_number,
        nf_number,
        client_cnpj,
        schedule_id: parseInt(schedule_id),
        triangulation_complete: true,
        date_validated: dpResult.date_validated,
        date_match: dpResult.date_match,
        strategy_used: dpResult.strategy_used,
        found_at: dpResult.found_at,
        details: {
          cnpj_in_record: dpResult.cnpj,
          client_in_record: dpResult.client_number,
          nf_in_record: dpResult.nf_number,
          dt_inclusao: dpResult.dt_inclusao,
          situacao: dpResult.situacao
        }
      });
    } else {
      console.log(`‚ùå [API-TRIANGULATION] Triangula√ß√£o falhou - NF: ${nf_number}, CNPJ: ${client_cnpj}`);
      
      res.status(404).json({
        success: false,
        message: 'DP n√£o encontrado - triangula√ß√£o falhou',
        reason: 'Sem correspond√™ncia exata de CNPJ + NF + Data de inclus√£o',
        nf_number,
        client_cnpj,
        schedule_id: parseInt(schedule_id),
        triangulation_complete: false,
        suggestions: [
          'Verifique se a data de altera√ß√£o para "Agendado" est√° no hist√≥rico',
          'Confirme se o CNPJ est√° correto',
          'Verifique se a NF est√° correta',
          'Confirme se existe registro na tabela WTR com data de inclus√£o correspondente'
        ]
      });
    }
  } catch (error) {
    console.error('‚ùå [API-TRIANGULATION] Erro na triangula√ß√£o:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno na triangula√ß√£o de DP',
      error: error.message
    });
  }
});

/**
 * Busca DP diretamente na tabela wtr por NF e cliente (OTIMIZADO)
 */
router.get('/search-dp', async (req, res) => {
  try {
    const { nf_number, client_cnpj, client_number } = req.query;
    
    if (!nf_number || !client_cnpj) {
      return res.status(400).json({
        success: false,
        message: 'Par√¢metros nf_number e client_cnpj s√£o obrigat√≥rios'
      });
    }

    // Usar servi√ßo otimizado para buscar na tabela WTR
    const DPVerificationServiceOptimized = require('../services/dpVerificationServiceOptimized');
    const dpService = new DPVerificationServiceOptimized();
    
    console.log(`üîç [API-SEARCH] Buscando DP - NF: ${nf_number}, CNPJ: ${client_cnpj}`);
    
    const dpResult = await dpService.getDPFromWtrTableOptimized(
      nf_number, 
      client_cnpj, 
      client_number || null
    );
    
    if (dpResult) {
      console.log(`‚úÖ [API-SEARCH] DP encontrado: ${dpResult.dp_number} (${dpResult.strategy_used})`);
      
      res.json({
        success: true,
        message: 'DP encontrado na tabela WTR',
        no_dp: dpResult.dp_number,
        nf_number,
        client_cnpj,
        strategy_used: dpResult.strategy_used,
        found_at: dpResult.found_at,
        details: {
          cnpj_in_record: dpResult.cnpj,
          client_in_record: dpResult.client_number,
          nf_in_record: dpResult.nf_number
        }
      });
    } else {
      console.log(`‚ùå [API-SEARCH] DP n√£o encontrado - NF: ${nf_number}, CNPJ: ${client_cnpj}`);
      
      res.status(404).json({
        success: false,
        message: 'DP n√£o encontrado na tabela WTR para os par√¢metros fornecidos',
        nf_number,
        client_cnpj,
        suggestions: [
          'Verifique se a NF est√° correta',
          'Verifique se o CNPJ est√° formatado corretamente',
          'Tente adicionar o par√¢metro client_number para fallback'
        ]
      });
    }
  } catch (error) {
    console.error('Erro na busca de DP:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno na busca de DP',
      error: error.message
    });
  }
});

/**
 * Testa a funcionalidade de triangula√ß√£o com dados de exemplo
 */
router.post('/test-triangulation', async (req, res) => {
  try {
    const { nf_number, client_cnpj, schedule_id, test_mode = false } = req.body;
    
    if (!nf_number || !client_cnpj) {
      return res.status(400).json({
        success: false,
        message: 'Par√¢metros nf_number e client_cnpj s√£o obrigat√≥rios para teste',
        required_params: ['nf_number', 'client_cnpj']
      });
    }

    console.log(`üß™ [TEST-TRIANGULATION] Iniciando teste de triangula√ß√£o`);
    console.log(`   NF: ${nf_number}, CNPJ: ${client_cnpj}, Schedule ID: ${schedule_id || 'N/A'}`);
    console.log(`   Modo teste: ${test_mode}`);

    const DPVerificationServiceWithDate = require('../services/dpVerificationServiceWithDate');
    const dpService = new DPVerificationServiceWithDate();
    
    let testResults = {
      triangulation_test: null,
      validation_test: null,
      statistics: null
    };

    // Teste 1: Triangula√ß√£o rigorosa
    if (schedule_id) {
      console.log(`üîç [TEST] Testando triangula√ß√£o rigorosa...`);
      testResults.triangulation_test = await dpService.getDPFromWtrTableWithTriangulation(
        nf_number, 
        client_cnpj, 
        parseInt(schedule_id)
      );
    }

    // Teste 2: Valida√ß√£o de estrutura WTR
    console.log(`üîç [TEST] Validando estrutura da tabela WTR...`);
    testResults.validation_test = await dpService.validateWTRStructure();

    // Teste 3: Estat√≠sticas
    testResults.statistics = dpService.getStatistics();

    const hasValidTriangulation = testResults.triangulation_test && testResults.triangulation_test.triangulation_complete;
    
    res.json({
      success: true,
      message: 'Teste de triangula√ß√£o conclu√≠do',
      test_params: {
        nf_number,
        client_cnpj,
        schedule_id: schedule_id ? parseInt(schedule_id) : null,
        test_mode
      },
      results: {
        triangulation: {
          success: hasValidTriangulation,
          data: testResults.triangulation_test,
          message: hasValidTriangulation 
            ? `DP ${testResults.triangulation_test.dp_number} encontrado com triangula√ß√£o v√°lida`
            : 'Triangula√ß√£o falhou - sem correspond√™ncia exata de CNPJ + NF + Data'
        },
        wtr_structure: testResults.validation_test,
        service_statistics: testResults.statistics
      },
      recommendations: hasValidTriangulation 
        ? [
            'Triangula√ß√£o funcionando corretamente',
            'Todos os tr√™s crit√©rios foram atendidos: CNPJ + NF + Data',
            'DP pode ser capturado com seguran√ßa'
          ]
        : [
            'Triangula√ß√£o n√£o encontrou correspond√™ncia v√°lida',
            'Verifique se os dados est√£o corretos',
            'Confirme se existe registro na WTR com data correspondente',
            schedule_id ? 'Data de altera√ß√£o para "Agendado" encontrada no hist√≥rico' : 'Forne√ßa schedule_id para valida√ß√£o completa'
          ]
    });

  } catch (error) {
    console.error('‚ùå [TEST-TRIANGULATION] Erro no teste:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno no teste de triangula√ß√£o',
      error: error.message
    });
  }
});

/**
 * Lista agendamentos que ainda n√£o t√™m DP atribu√≠do
 */
router.get('/schedules-without-dp', async (req, res) => {
  try {
    const schedules = await dpVerificationService.getSchedulesWithoutDP();
    
    res.json({
      success: true,
      message: `${schedules.length} agendamentos sem DP encontrados`,
      data: schedules,
      total: schedules.length
    });
  } catch (error) {
    console.error('Erro ao listar agendamentos sem DP:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao listar agendamentos sem DP',
      error: error.message
    });
  }
});

module.exports = router;